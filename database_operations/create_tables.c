/**
 * @file create_tables.c
 * @brief Functions to create SQLite tables from ingested CSV files.
 *
 * This file contains functions to create SQL commands from CSV data,
 * manage column definitions, and execute table creation in an SQLite database.
 */
#include <glib.h>
#include <headers.h>
#include <string.h>

/**
 * @brief Constructs a full CSV filename from a directory path and filename.
 *
 * This function concatenates the provided directory and CSV file name
 * into a single full path.
 *
 * @param directory The path where the CSV file is located.
 * @param csv_file The name of the CSV file.
 * @return gchar* A newly allocated string containing the full CSV filename.
 */
gchar* make_csv_filename(const gchar *directory, const gchar *csv_file) {
	return g_strconcat(directory, csv_file, NULL);
}

/**
 * @brief Frees the memory allocated for a Column_Definition.
 *
 * This callback function is used to free the memory of a Column_Definition
 * object that has been dynamically allocated.
 *
 * @param data A pointer to the dynamically allocated Column_Definition object.
 * @sa make_table
 */
void free_column_info(gpointer data) {
	g_free((Column_Definition*) data);
}


/**
 * @brief Builds SQL column definition clauses for table definitions.
 *
 * This callback function concatenates SQL column definitions based on the list of
 * column definitions.
 *
 * @param data A pointer to a Column_Definition for the current column.
 * @param user_data A pointer to the command string being constructed.
 * @sa make_create_command
 */
void make_clause(gpointer data, gpointer user_data) {
	Column_Definition *column_definition = (Column_Definition*) data;
	gchar **command_pointer = (gchar**) user_data;
	*command_pointer = g_stpcpy(*command_pointer,
			column_definition->column_name);
	*command_pointer = g_stpcpy(*command_pointer, " ");
	switch (column_definition->column_type) {
	case NULL_S:
		*command_pointer = g_stpcpy(*command_pointer, "NULL");
		break;
	case INTEGER:
		*command_pointer = g_stpcpy(*command_pointer, "INTEGER");
		break;
	case REAL:
		*command_pointer = g_stpcpy(*command_pointer, "REAL");
		break;
	case TEXT:
		*command_pointer = g_stpcpy(*command_pointer, "TEXT");
		break;
	default:

	}
	if (column_definition->is_primary_key) {
		*command_pointer = g_stpcpy(*command_pointer, " PRIMARY KEY");
	}
	*command_pointer = g_stpcpy(*command_pointer, ", ");
}

/**
 * @brief Constructs a `CREATE TABLE` SQL command.
 *
 * This function generates a SQL `CREATE TABLE` command using the provided
 * table name and columns, and also considers foreign key constraints.
 *
 * @param table_name The name of the table to be created.
 * @param table_columns A linked list of Column_Definition to define table columns.
 * @param data_passer A pointer to the Data_Passer structure containing context.
 * @return gchar* A newly allocated string containing the CREATE TABLE command.
 * @sa execute_create_table_command
 */
gchar* make_create_command(const gchar *table_name, GSList *table_columns,
		Data_Passer *data_passer) {
	gchar *create_command = g_malloc(sizeof(gchar) * MAX_SQLITE_LENGTH);
	gchar *command_pointer = g_stpcpy(create_command, "CREATE TABLE ");
	command_pointer = g_stpcpy(command_pointer, table_name);
	command_pointer = g_stpcpy(command_pointer, " (");

	g_slist_foreach(table_columns, make_clause, &command_pointer);

	/* Find the record containing the current table, check if it has foreign keys. */
	GSList *table_list = g_slist_find_custom(data_passer->table_characteristics,
			table_name, find_table_definition_with_foreign_key);

	if (table_list) {
		Table_Characteristic *table_characteristic =
				(Table_Characteristic*) table_list->data;

		command_pointer = g_strrstr(create_command, ",") + 1;
		g_slist_foreach(table_characteristic->foreign_keys, make_foreign_keys,
				&command_pointer);
		command_pointer = g_strrstr(create_command, ",");
		command_pointer = g_stpcpy(command_pointer, ")");
	} else {
		/* For tables without a foreign key, replace trailing comma-space with a closing paren */
		command_pointer = g_strrstr(create_command, ", ");
		command_pointer = g_stpcpy(command_pointer, ")");
	}

	return create_command;
}

/**
 * @brief Executes a SQL `CREATE TABLE` command.
 *
 * This function runs the `CREATE TABLE` SQL command generated by make_create_command.
 *
 * @param create_command The SQL CREATE TABLE command to execute.
 * @param data_passer A pointer to the Data_Passer structure for logging.
 * @sa make_create_command
 */
void execute_create_table_command(const gchar *create_command,
		Data_Passer *data_passer) {
	g_print("%s\n", create_command);
	gchar *errmsg = NULL;
	int rc = sqlite3_exec(data_passer->run_time.db, create_command, 0, 0,
			&errmsg);
	if (rc != SQLITE_OK) {
		g_print("SQL error: %s\n", errmsg);
		sqlite3_free(errmsg); // Free the error message if needed
	}
}


/**
 * @brief Ingests a CSV file into a table.
 *
 * This function opens a CSV file, reads its content, builds column definitions,
 * generates a `CREATE TABLE` command, and executes it to create a new table
 * in the database.
 *
 * @param filename A pointer to the CSV filename to process.
 * @param user_data A pointer to the Data_Passer structure containing context.
 * @sa make_create_command
 * @sa execute_create_table_command
 * @sa populate_table
 */
void make_table(gpointer filename, gpointer user_data) {
	Data_Passer *data_passer = (Data_Passer*) user_data;
	gchar *csv_filename = (gchar*) filename;

	gchar *csv_pathname = make_csv_filename(data_passer->csv_file_directory,
			csv_filename);
	g_print("Processing %s\n", (gchar*) csv_pathname);

	FILE *file = fopen(csv_pathname, "r");
	if (!file) {
		g_print("Error opening csv file %s\n", (gchar*) csv_pathname);
		g_free(csv_pathname);
		return;
	}
	gchar line[MAX_CSV_FILE_LINE_LENGTH];
	fgets(line, sizeof(line), file);
	/* Save the start of the CSV data, use it when populating the table. */
	guint csv_start = strlen(line);
	GMatchInfo *match_info = NULL;
	data_passer->error = NULL;

	g_regex_match(data_passer->csv_column_name_regex, line, 0, &match_info);
	if (data_passer->error) {
		g_print("Error matching regex: %s\n", data_passer->error->message);
		g_error_free(data_passer->error);
		data_passer->error = NULL;
		return;
	}
	guint number_columns = 0;
	GSList *table_columns = NULL;
	gchar *match = NULL;
	gchar table_name[MAX_COLUMN_NAME_LENGTH];
	/* Parse the column names appearing in the first row */
	do {
		match = g_match_info_fetch(match_info, 1); // Fetch the first capturing group
		if (match) {
			g_print("Found a column with title: %s\n", match);
			normalize_string(match);
			Column_Definition *column_definition = g_malloc(
					sizeof(Column_Definition));
			g_strlcpy(column_definition->column_name, match,
			MAX_COLUMN_NAME_LENGTH);
			column_definition->column_type = TRASH;
			column_definition->is_primary_key = FALSE;

			get_table_name_from_csv_name(table_name, csv_filename);
			GSList *table_list = g_slist_find_custom(
					data_passer->table_characteristics, table_name,
					find_table_definition);
			if (table_list) {
				Table_Characteristic *table_characteristic =
						(Table_Characteristic*) table_list->data;
				if ((table_characteristic->primary_key)
						&& strcmp(table_characteristic->primary_key,
								column_definition->column_name) == 0) {
					column_definition->is_primary_key = TRUE;
				}
			}

			table_columns = g_slist_append(table_columns, column_definition);
			number_columns++;

			g_free(match);
		}

	} while (g_match_info_next(match_info, &(data_passer->error)));

	g_match_info_free(match_info);
	/* Read from the second to last line, deciphering the SQLlite data type. */
	guint current_column;
	while (fgets(line, sizeof(line), file) != NULL) {
		g_regex_match(data_passer->csv_column_name_regex, line, 0, &match_info);
		if (data_passer->error) {
			g_print("Error matching regex: %s\n", data_passer->error->message);
			g_error_free(data_passer->error);
			data_passer->error = NULL;
			return;
		}

		current_column = 0;
		do {
			match = g_match_info_fetch(match_info, 1);
			//g_print("Found match: %s\n", match);
			do_sqlite_tests(match,
					g_slist_nth_data(table_columns, current_column));
			g_free(match);
			current_column++;
		} while (g_match_info_next(match_info, &(data_passer->error)));
		g_match_info_free(match_info);
	}

	gchar *create_command = make_create_command(table_name, table_columns,
			data_passer);
	write_log_message(G_LOG_LEVEL_INFO, create_command, data_passer->run_time.log_file);
	execute_create_table_command(create_command, data_passer);
	g_free(create_command);
	populate_table(file, csv_start, table_name, number_columns, table_columns, data_passer);
	g_slist_free_full(table_columns, free_column_info);
	fclose(file);
	g_free(csv_pathname);
}

